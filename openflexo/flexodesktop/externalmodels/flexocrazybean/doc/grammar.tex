\documentclass{article}
\usepackage{bnf,url}
\usepackage{palatino,a4wide}
\newcommand\comment[1]{\emph{\mbox{// #1}}\newline}

\newenvironment{mygrammar}{\begin{grammar}%
      [(colon){ $\rightarrow$}]%
      [(semicolon)$|$]%
      [(comma){ }]%
      [(period){\\}]%
      [(quote){\begin{bf}}{\end{bf}}]%
      [(nonterminal){$\langle$}{$\rangle$}]}%
      {\end{grammar}}

\title{Grammar and API for Rational Rose Petal files}

\author{M. Dahm}

\begin{document}
\maketitle

\begin{center}
  Version 1.1
\end{center}

\section{Introduction}

Rational Rose \cite{rose} is probably the most widely used tool for
software engineering processes, although it has several deficiencies
(which we will not discuss here). In the \textsc{CrazyBeans} project I
tried to tackle one of them related to the ``roundtrip engineering''
process.  One can import source files into Rose and create class
diagrams from them. Vice versa one can create classes (and IDL
specifications or whatever you need) from class (and other) diagrams.
Yet these creation processes can not be influenced by the user in a
convenient, flexible and extensible way. Another problem is that these
models are proprietary and some people would like to have the
possibility to write a converter for these models into a different
format used by another tool.

Every application developed and also every company follows different
policies and may need different conventions for the generated code. So
it is clearly desirable for them to influence the way in which
diagrams and other data are mapped to source code and vice versa. For
example, one company might have the convention to attach notes to
classes and associations containing OCL \cite{ocl} statements (or
whatever). Rose wouldn't not not regard them when creating code, but a
tool specifically adapted for this need could do so.

So how can all this be accomplished? Well, the easiest way is to have an
API that is capable of reading and writing the files created by
Rational Rose, called ``Petal files'' (ending with \texttt{.mdl} or
\texttt{.ptl}) which contain the given model of the application. The
file format is undocumented, I'll try to explain it in the following
sections anyway. The \textsc{CrazyBeans} API to read and write these
files is explained in section \ref{api}.

\subsection{Petal file format}

The format of petal files generated by Rational Rose (ending with
\texttt{.mdl} or \texttt{.ptl}) is not documented, yet it is an ASCII
format, fortunately. We have been able to match several entities of its
contents to what you see on the screen. Yet we do not understand all of
it and some parts of the file seem not to be of general interest. I
focused mostly on interpreting class diagrams, though use case
und other diagrams can be analyzed, too.

The file format looks roughly like a lisp data structure, consisting
of several nested levels enclosed in parentheses which form a \emph{tree}
of nodes.  Take a look at one of your files yourself to see what I
mean. The main data structure are ``objects'', i.e., items like

\begin{verbatim}
  (object Petal
     version     42
     _written    "Rose 4.5.8163.3"
     charSet     0)
\end{verbatim}

These objects always have a name (``Petal'' in the example), optional
parameter strings and an optional tag. The general form of is shown in
section \ref{simple}.  There is quite a number of different kinds
objects. We mapped them to Java classes which can be found in the
package \texttt{cb.petal}. The file format itself is not very
``object-oriented'', but we tried to use subclassing wherever it made
sense. All objects have a number of properties which are mapped to
set/get methods in the Java classes. A special property is the
``quid'' (which probably stands for ``qualified identifier''), a
globally unique identfier (coded as a hexadecimal number) for an
object. References to other objects (e.g. an associaton) are defined
by the ``quidu'' property.

There are two parts of  a petal file which are of general interest for
us: One section specifies the data model (classes, associations, ...)
and another one specifies the ``views'' for the model (there may be
many). The views are what you see on the screen although the
underlying model may contain more information. This model-view pattern
might ring a bell for some readers... Views may also contain
additional ``notes'' which are not part of the data model but can be
thought of as some kind of comments.

The following section gives an (incomplete) BNF grammar for petal files.

\section{The grammar}

Identifiers in angle brackets denote non-terminals, text in
double-quotes denotes strings, bold text denotes terminal symbols.
Comments are written \emph{italic} and start with two slashes. Not all
existing petal objects are listed here, because there are too many.
However, the generic form is shown in section \ref{simple} which all
petal objects conform to. Please refer to the concrete Java files in
package \texttt{cb.petal} for details of the adjustable properties.
The order of properties does not matter in most cases (sometimes Rose
seems to be picky). The ugly thing is that property names may occur
multiply, e.g., an object may have multiple ``label''s attached to it.

\subsection{Petal nodes}

The tree defined by the petal file may have the following kinds of
nodes:

\begin{mygrammar}
<PetalNode>: <Object> ; <Literal> ; <List>.

<List>:      "(list", <name>, <Object>*, ")".

<Literal>:
             <Value> ; <Tuple> ; <Tag> ; <Location> ;
             <stringliteral> ; <int> ; <boolean> ; <float>.

<Value>:     "(value", <name>, <stringliteral>, ")".

<Tuple>:     "(", <string>, <int>, ")".

<Tag>:       "@"<int>.

<Location>:  "(", <int> ",", <int>, ")".
\end{mygrammar}

All of them are leaf nodes except for Object and List. The literals
will be defined in section \ref{literals}.

\subsection{General format of an object}\label{simple}

An object always has a name and optionally a list of strings which I
call parameters, and some markup the form \texttt{@2} that we call
``tags''. The first parameter is usually the name for that object, the
class name, e.g.. The second parameter may be the fully qualified name
of an object. Tags are used in the context of views only and their
purpose is to provide some local numbering mechanism.

Most objects have a ``quid'' property and can be either be identified
by this unique number or by their fully-qualified name which is given
by their position in the tree (e.g., ``\texttt{Logical
View::University::Professor}'').

Objects just consist of a list of key-value pair of properties,
property names may occur multiply in some case, i.e. are not
necessarily unique within the list. We will usually not list all
possible properties, but only those of special interest.

\begin{mygrammar}
<Object>: "(object", <name>, <string>* [<Tag>]\newline
          (<name>, <PetalNode>)*
")".
\end{mygrammar}

\subsubsection{Example}

The following examples shows how a plain ``Student''class derived from
class ``Person'' is represented. It has three properties (it may be
more in fact) where two of them refer to literals and one
(``superclasses'') refers to a list of other classes which are
identified via the quidu property. This is a list, because languages
like C++ allow multiple inheritance.

\begin{verbatim}
  (object Class "Student"
     quid          "3AE987720329"
     superclasses  (list inheritance_relationship_list
                      (object Inheritance_Relationship
                         quid        "3AE9877B01D8"
                         supplier    "Logical View::University::Person"
                         quidu       "3AE987400197"))
     language      "Java")
\end{verbatim}

\subsection{Literals}\label{literals}

Strings come in two flavors: The standard string with text between two
double quotes and multi-line strings where each line starts with $|$.

\begin{mygrammar}
<multistring>: <newline> ("$|$" <text>)+ .
<string>: \textbf{``}<text>\textbf{''}.
<stringliteral>: <string> ; <multistring>.
\end{mygrammar}

Qualified names have the form \texttt{ClassCategory::Package::Class}, for
example, ``\texttt{Logical View::University::Professor}''.

\begin{mygrammar}
<qname>: <string>.
\end{mygrammar}

The rest is pretty much standard.

\begin{mygrammar}
<name>: <char> (<char> ; <digit>)* .
<text>: <anychar>* .
<ident>: ``<hexnumber>''.
<number>: <digit>+.
<hexnumber>: (<digit> ; <hexdigit>)+.
<digit>: "0" ; "1" ; "2" ; "3" ; "4" ; "5" ; "6" ; "7" ; "8" ; "9".
<hexdigit>: "A" ; "B" ; "C" ; "D" ; "E" ; "F".
<int>: ["-"] <number>.
<float>: ["-"] <number> "."  <number>.
<boolean>: "TRUE" ; "FALSE".
<char>: "a" ; "b" ; \dots\ ; "z" ; "A" ; "B" ; \dots\ ; "Z".
<ws>: <blank> ; <tab>.
\end{mygrammar}

\section{Petal file format}

Starting from the root of the file the overall structure looks like
this:

\begin{mygrammar}
<petalfile>: <petal>, <design>.

<petal>: "(object", "Petal"\newline
               "version",   <number>\newline
               "\_written", <ident>\newline
               "charSet",   <number> ")".

<design>: "(object", "Design", ``Logical View'', \newline
    "is\_unit",                   "TRUE", \newline
    "is\_loaded",                 "TRUE", \newline
    "quid",                       <ident>, \newline
    "defaults",                   <Defaults>, \newline
    "root\_usecase\_package",     <UseCaseCategory>, \newline
    "root\_category",             <LogicalCategory>, \newline
    "root\_subsystem",            <SubSystem>, \newline
    "process\_structure",         <Processes>, \newline
    "properties",                 <Properties>, \newline
")".
\end{mygrammar}

\subsection{Class categories}\label{logical}

Now the interesting part is the logical view of the petal file
(property root\_category), because it contains all the class
diagrams. Therefore we just explored this part in depth. The
root\_usecase\_package contains use case diagrams, root\_subsystem
component diagrams, and process\_structure contains sequence
diagrams. Their structure is quite similar to the LogicalCategory.

\begin{mygrammar}
<LogicalCategory>: "(object", "Class\_Category" ``Logical View''\newline
         "quid",               <ident>\newline
         "exportControl",      <string>\newline
         \dots\newline
         "logical\_models",            <List> \comment{of Class,
         Association and further ClassCategory objects}
         "logical\_presentations",     <List> \comment{of ClassDiagram objects}
         "properties",                 <Properties>
")".

<Properties>: "(object",  "Properties"\newline
              "attributes", <List> \comment{of attribute objects}
")".
\end{mygrammar}

The first list specifies the possible contents of the class (and
other) diagrams, classes and associations, in particular, and serves
as a data model. It also may contain further LogicalCategory objects
and the data model for interaction/sequence diagrams in so called
Mechanism objects. The second list specifies the views (in this case
class diagrams) in which these classes and associations may appear(see
section \ref{views}).

\subsection{Class}

A class object (i.e. a member of the first list) contains all the
information you might expect in a class, encapsulated in further
objects. It contains fields, methods, references to the
superclass(es), and the implemented interfaces. Classes may also have
an access modifier and a stereotype associated with them. Just the
naming convention is a little bit different in Rose (in terms of usual
Java naming conventions): Methods are operations, fields are class
attributes, access modfiers are named ``exportControl'', and
``implement'' is called ``realize''.

\begin{mygrammar}
<Class>: "(object", "Class", <string> \comment{class name}
         "quid",                <ident>\newline
         "operations",            <List> \comment{of Operation objects}
         "class\_attributes",     <List> \comment{of ClassAttribute objects}
         "superclasses",          <List> \comment{of InheritanceRelationship objects}
         "used\_nodes",           <List> \comment{of UsesRelationship objects}
         "realized\_interfaces",  <List> \comment{of RealizeRelationship objects}
         "exportControl",       <string>\newline
         "language",            <string>\newline
         "stereotype",          <string>
")".
\end{mygrammar}

For (Java) interfaces the convention is to have an ``Interface''
stereotype for the class.

\subsubsection{Operation objects}

\begin{mygrammar}
<Operation>: "(object", "Operation", <string> \comment{method name}
         "quid",                <ident>\newline
         "parameters",            <List> \comment{of formal Parameter objects}
         "result",              <string> \comment{return type}
         "opExportControl",     <string>\newline
         "stereotype",          <string>
")".
\end{mygrammar}

\subsubsection{Class attributes}

\begin{mygrammar}
<ClassAttribute>: "(object", "ClassAttribute", <string> \comment{attribute name}
         "quid",              <ident>\newline
         "type",              <string> \comment{attribute type}
         "exportControl",     <string>\newline
         "stereotype",        <string>
")".
\end{mygrammar}

\subsubsection{Inheritance relationship}\label{inherit}

\begin{mygrammar}
<InheritanceRelationship>: "(object", "Inheritance\_Relationship", <string>\newline
         "supplier",          <string> \comment{e.g. Logical View$\colon\colon$Person}
         "quidu",             <ident> \comment{ID of referenced class, e.g., Person}
         "quid",              <ident>
")".
\end{mygrammar}

\subsubsection{Uses relationship}

\begin{mygrammar}
<UsesRelationship>: "(object", "Uses\_Relationship", <string>\newline
         "supplier",          <qname> \comment{e.g. Logical View$\colon\colon$Person}
         "quidu",             <ident> \comment{ID of used class, e.g. Person}
         "quid",              <ident>
")".
\end{mygrammar}

\subsubsection{Realize relationship}

\begin{mygrammar}
<RealizeRelationship>: "(object", "Realize\_Relationship", <string>\newline
         "supplier",          <qname>
         "quidu",             <ident> \comment{ID of implemented interface}
         "quid",              <ident>
")".
\end{mygrammar}


\subsection{Associations}\label{assoc}

An association contains a list of (exactly two) roles, i.e. both ends of the
association are described with their role name, cardinality, etc..

\begin{mygrammar}
<Association>: "(object", "Association", <string> \comment{association name}
         "roles",               <List> \comment{of Role objects}
         "AssociationClass",    <qname> \comment{of association class}
         "quid",                <ident>
")".
\end{mygrammar}

\subsubsection{Role objects}

\begin{mygrammar}
<Role>: "(object", "Role", <string> \comment{role name}\newline
         "supplier",          <qname> \comment{associated with the given class}
         "quidu",             <ident> \comment{ID of associated class}
         "is\_navigable",     <boolean> \comment{navigable in both directions?}
         "is\_aggregate",     <boolean> \comment{aggregation?}
         "Containment",       <string> \comment{shared aggregation?}
         "client\_cardinality", <Value> \comment{cardinality, like 1\dots n}
         "quid",              <ident>
")".
\end{mygrammar}

If ``is\_navigable'' is false, the association can only be read in one
direction. ``is\_aggregate'' specifies whether this is an aggregation
(drawn as a rhomb), the ``Containment'' of the \emph{other} role
specifies whether it is a shared aggregation, i.e., possible values
are ``By value'' and ``By reference''. The ``client\_cardinality''
(obviously) specifies the cardinality of the role.

\subsection{Mechanism objects}\label{mechanism}

Mechanism object contain the abstract description of a sequence or
collaboration diagram (which are semantically equivalent).

TODO

\section{Class and other diagrams}\label{views}

A Rose model may contain one or more class diagrams (and other kinds
of diagrams not described here). They are listed under the
``logical\_presentations'' property of the class category ``Logical
View'' (see section \ref{logical}).

\begin{mygrammar}
<ClassDiagram>: "(object", "ClassDiagram", <string> \comment{class name}
         "quid",               <ident>\newline
         "title",              <string>\newline
         "zoom",               <int>\newline
         "max\_height",         <int>\newline    
         "max\_width",          <int>\newline    
         "origin\_x",           <int>\newline    
         "origin\_y",           <int>\newline    
         "items",              <List> \comment{of View objects}
")".
\end{mygrammar}

\subsection{View objects}

There are several View objects that may be listed in the ``items'' list,
in particular class views, association views (for some peculiar reason
named AssociationViewNew), note views, etc.. In general there are view
objects for eveything listed in the ``logical\_models'' property of the ``Logical
View'' (see section \ref{logical}). View objects do have no quid
property, but most of them have a tag.

\subsubsection{ClassView objects}

\begin{mygrammar}
<ClassView>: "(object", "ClassView", <string>, <string> <Tag>\comment{FQN and index}
         "location",           <Location>\newline
         "quidu",              <ident>\newline
         "label",              <ItemLabel>\newline
         "stereotype",         <ItemLabel>\newline
")".

<ItemLabel>: "(object", "ItemLabel"\newline
         "location",           <Location>\newline
         "Parent\_View",       <Tag> \comment{Tag of the class view}
         "label",              <string>\newline
")".
\end{mygrammar}

The tag of the class view is a running number and the first string is
always equal to ``Class'' and the second refers to the fully qualified
name of the class. In the ItemLabel object the interesting properties
are ``label'' which defines the text to be displayed and
``Parent\_View'' which is the same tag as the surrounding class view.

\subsubsection{Example}
\begin{verbatim}
  (object ClassView "Class" "Logical View::Mentor" @2
     location (304, 1152)
     label    (object ItemLabel
                 Parent_View @2
                 location    (172, 1145)
                 label       "Mentor")
     stereotype (object ItemLabel
                   Parent_View @2
                   location    (172, 1095)
                   label       "<<Interface>>")
     icon            "Interface"
     icon_style      "Label"
     quidu           "3AE987AB0209"
     width           282)
\end{verbatim}

\subsubsection{AssociationViewNew objects}

Associations (\ref{assoc}) are displayed with AssociationViewNew
objects, there is nothing really new for them to the reader except
that their labels are of a different type and that the roles of an
association are mapped to according RoleView objects. It's probably
best to see an example again:

\begin{verbatim}
  (object AssociationViewNew "teach" @12
    location   (710, 720)
    label      (object SegLabel @13
      Parent_View @12
      location   (710, 661)
      font       (object Font
                   italics    TRUE))
    line_color 3342489
    quidu      "3AE988420057"
    roleview_list (list RoleViews
      (object RoleView "$UNNAMED$0" @14
        Parent_View @12
        location   (310, 0)
        quidu      "3AE988420332"
        client     @12
        supplier   @4
        line_style 0)
      (object RoleView "$UNNAMED$1" @15
        Parent_View @12
        location   (310, 0)
        quidu      "3AE988420333"
        client     @12
        supplier   @8
        line_style 0)))
\end{verbatim}

\subsubsection{Other view objects}

There several other view objects describing relations between objects
which are very similar in pattern, in particular InheritView,
RealizeView, AttachView, and UsesView. The general syntax of them is:

\begin{mygrammar}
<OtherView>: "(object", <name>, <Tag>\newline
        "quidu",        <ident>\newline
        "client",       <Tag>\newline
        "supplier",     <Tag>\newline
).
\end{mygrammar}

For example, for an InheritView, the ``quidu'' would refer to the
according InheritanceRelationship object (see \ref{inherit}). The
``client'' and ``supplier'' property refer to the tags of the class view
objects that represent the class and its super class.

There are probably even more view objects we forgot to mention,
NoteView, for instance, but they're quite similar.

\section{The CrazyBeans framework}\label{api}

The file format is in fact not ``object-oriented'', though it is
obviously targeted to describe object-oriented structures. This means
that the hierarchy of classes and interfaces we developed for Crazy
Beans is rather arbitrary. We probably made some wrong assumptions and
we tested it only with the models we could get hold on. We tried to give
the API some structure using subclassing and through interfaces.

There are probably cases where a petal object parsed from a file does
not define a certain property although the API may claim so. We're out of
luck here, because we only can verify that empirically. Sometimes worse
the meaning of properties is often ``overloaded'', i.e., the property
``stereotype'' sometimes refers to a string (as one would assume),
somtimes to a label, and may be even a boolean value.

This being said, it works quite well for me by now and ww hope it does
for your purposes, too. distribution contains four packages which are
briefly described in the following sections. Please refer to the
distributed API documentation and the examples for details.

\subsection{The Petal package}

This part of the API contained in the package \texttt{cb.petal}
contains all the nodes (we could find) that make up a Rose petal
file. I.e, every entity found in a model is mapped to class. This is
true as well for basic structures such as lists and literals as well
as for ``petal objects'' (see \ref{simple}). There are methods to set
and remove properties.

Every petal object has an \texttt{accept()} method to be used in
conjunction with the visitor pattern. There also some predefined
visitors that use certain traversal strategies. You should subclass
these instead of writing own visitor, because the visitor may change
if new entities of interest are discovered.

Petal objects also contain a pointer to their containing parent in the
tree formed by a petal file.  They also have an \texttt{init()} method
which is called after they have been added to model. This is used,
e.g., to maintain lookup information. The root of the tree is called
\texttt{PetalFile} and contains additional lookup methods, for
example, to find an entity by its \texttt{quid} property or a class by
its fully qualified name.

\subsection{The parser package}

The classes in \texttt{cb.parser} simply make up a parser for petal
files, the parser is written using JavaCC \cite{javacc}. It makes sure
that all references (e.g. pointers to the parent node) are set up
correctly and that \texttt{init()} gets called.

\subsection{The utility package}

This package obviously contains useful classes for the API. Of special
interest might be the \texttt{PetalObjectFactory}, which allows to
create petal objects with more comfort. It reads serialized template
objects from \texttt{templates} directory. The factory does not call
\texttt{init()} on the created objects, this is done when the objects
have been added to the model.

\subsection{The generator package}

The framework defined here allows you to create classes (or whatever)
from class diagrams. The two main classes are the \texttt{Generator}
which mainly takes care of the traversal and the \texttt{Factory}
which maps petal objects to some kind of abstract syntax tree (AST).

For you needs you'll probably just have to subclass the factory and
override the methods of interest. The current default implementation
is quit simplistic, in particular when mapping associations. It simply
maps them to a newly created classes that maintains the connections
and adds access methods to the connected classes.

\bibliographystyle{plain} \bibliography{grammar}


\appendix

\section{Quid identifiers and resolution of object references}

The following informations can be found in the FAQ of the Rational
Rose web site:

A unique id is simply the current time expressed as the number of
seconds elapsed since some point in time in the past, concatenated
with some random nuber.  The generation algorithm also guarantees that
the id will be unique during any given session of Rose and in general,
will be unique for all models/units generated on a single machine,
assuming the date never gets set backwards.  It's not likely that
duplicate ids will be generated, however the resolution algorithm
makes it even less likely that it would lead to a problem, because:

\begin{enumerate}
\item most references are resolved by name first and only if name
  resolution fails, e.g. the name changed while the referencing item
  was in an unloaded unit, will it check unique ids.

\item When resolving a unique id reference, the kind of thing being
  searched for is always used.  For example, if the code searches for
  uid 12345, kind Class, it would never find a package even if there
  was one that had uid 12345.
\end{enumerate}
 
 How and when Rose needs these UIDs, i.e. how Rose is accessing
 elements. This is done with the following algorithm:
\begin{enumerate}
\item Rose searches after the Qualified Name of the element (i.e.
  package-hierarchy::element.name
  
\item When not finding the element, Rose searches within all model
  elements of the same element type (i.e. it doesn't search the use
  cases, if it's searching a class) after the element with the same
  UID.
  
\item if it doesn't find the element type WITH matching UID, it places
  the (M) circle sign in the diagram, or places parenthesis around the
  textual references.  (i.e. if you attached a class to an object in a
  scenario diagram, and then delete the class, the name will stay
  there, but in paranthesis. If you then recreate the class (which
  gives it another UID!), it is 'reconnected' to the object)
\end{enumerate}


\end{document}
